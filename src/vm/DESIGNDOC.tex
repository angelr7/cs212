            +---------------------------+
            |          CS 212           |
            | PROJECT 3: VIRTUAL MEMORY |
            |      DESIGN DOCUMENT      |
            +---------------------------+

---- GROUP ----

>> Fill in the names and email addresses of your group members.
Angel Ruiz <ar7@stanford.edu>
Pilli Cruz-De Jesus <pilli@stanford.edu>
Fabian Luna <luna1206@stanford.edu>

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.

            PAGE TABLE MANAGEMENT
            =====================

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

/* This is our supplemental page struct, it keeps
track of all information needed to retrieve a page
of information in swap or file and write it to memory. */
struct page {
    /* In Memory */
    struct frame_entry *frame;
    void *physical_addr;

    /* In Disk */
    struct file *file;
    off_t file_ofs;
    size_t page_read_bytes;
    size_t page_zero_bytes;
    mapid_t mapid;

    /* In Swap*/
    int swap_slot;

    /* Everything */
    void *virtual_addr;
    struct hash_elem hash_elem;
    struct thread *process_reference;
    short memory_flag;    
    bool writable;
};

/* This member was added into the thread struct so that each 
   process can manage its own SPT. */
struct hash spt;

---- ALGORITHMS ----

>> A2: In a few paragraphs, describe your code for accessing the data
>> stored in the SPT about a given page.
Our SPT is in the form of a hash table, and each one of its items is 
represented by our page struct. For this reason, all of our page logic
with the SPT uses functions like hash_insert and hash_find to access and 
interact with the stored page data. In our implementation, we only use two
functions to access the data stored about a given page: page_fetch and 
load_page. These functions fetch the page data from the SPT and load the 
page into the memory, respectively.

page_fetch is a rather simple function, and simply grabs the page 
reference from a given thread's SPT. We first begin by rounding down a 
user address to find the page entry that corresponds to that address. We
then declare a struct page variable, but only fill in the virtual 
address for that page, so that we can pass it into the hash_find function.
This function finds the hash_elem with the corresponding user address if 
it exists, and returns NULL if it doesn't. We then use the hash_entry call 
in order to convert the hash_elem that into a struct page and return it.

load_page first tries to find a page entry in the SPT for a given 
fault_addr. If the fault_addr returns NULL, we check to see if our stack
is trying to grow itself; if not, we return false, because there's no page
to load from the SPT. If we do have an address, however, we fetch the 
frame for that given user page; if the page has not yet had a 
physical_address assigned to it, we return false. In the event that there 
is a frame for that address, we then fetch that data, whether it is zeroed,
on swap, etc, and set that information in the page, along with its memory 
flag to indicate it's in memory. If there are any errors that we encounter
after we've fetched the frame, we make sure to free the frame before 
returning false.

>> A3: How does your code coordinate accessed and dirty bits between
>> kernel and user virtual addresses that alias a single frame, or
>> alternatively how do you avoid the issue?
To avoid any extra configuration with our codebase, we chose to exclusively 
access data through user virtual addresses. By avoiding any use of the 
actual physical address that a given virtual page is mapped to, we 
completely avoid dealing with data inconsistencies that may arise from 
holding that underlying kernel page. We have also not implemented file 
sharing at any point in time, so there are no other aliasing situations
that can arise in our ecosystem.

---- SYNCHRONIZATION ----

>> A4: When two user processes both need a new frame at the same time,
>> how are races avoided?
When we call get_frame, we get the new frame by accessing and modifying a
bitmap with the bitmap_scan_and_flip call. In order to avoid races in this
scenario, we have a bitmap_lock that is a static global that we define in 
page.c. This lock is initialized in the frame_table_init call, so we know 
that all threads will be able to access and use this lock as required. We 
use this lock when modifying the bitmap during a get_frame or free_frame 
call so that there are no read/write inconsistencies that may arise from 
races when freeing/getting frames.

---- RATIONALE ----

>> A5: Why did you choose the data structure(s) that you did for
>> representing virtual-to-physical mappings?
We used our page struct to represent our virtual-to-physical mappings. In
this struct, the virtual_addr, hash_elem, process_reference, memory_flag, 
and writeable boolean are always used. This allows us to manage the page 
and retrive information about it no matter where the kernel page for that 
user address is. In the event that the kernel page is in memory, swap, or 
on disk, we can simply check our memory_flag and do certain actions with
or on that page. Once checking this flag, we can then go on to use certain 
member variables that apply and can be used in each corresponding
situation.

               PAGING TO AND FROM DISK
               =======================

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

/* Frame entry structed used to fill the frame table 
contains frames physical address, virtual address,
process_thread, lock, and pinned boolean. */
struct frame_entry
{
    void *physical_address;         /* Physical address associated with this frame */
    void *virtual_address;          /* Virtual address associated with this frame */
    struct thread *process_thread;  /* Pointer to a process thread which owns this frame at this time */
    struct lock lock;               /* Lock */
    bool pinned;                    /* Bool to see if this frame is pinned */
};

static struct frame_entry **frame_table;    /* Array of frame_entry which makes up our frame table */
static size_t frame_table_size;             /* Frame Table Size */
static struct bitmap *used_map;             /* Bitmap which keeps track of which spaces in the frame_table are available */
static struct lock bitmap_lock;             /* Bitmap Lock */
static int cur_evict;                       /* Index to keep track of last eviction location in frame table */

static struct bitmap *used_map;
static struct block *swap_block;
static int num_slots;
static size_t sectors_per_page;
static struct lock swap_lock;

---- ALGORITHMS ----

>> B2: When a frame is required but none is free, some frame must be
>> evicted.  Describe your code for choosing a frame to evict.

 We utilized the clock algorithm to manage eviction. We start at the beginning
 of our array and then check each frames page table accessed bit using its
 virtual address. If accessed is true, we set it to false and continue. If
 accessed is false we evict that page. The next time we evict we continue
 at the page after the one previously evicted. Once we reach the end we jump
 back to the beginning.


>> B3: When a process P obtains a frame that was previously used by a
>> process Q, how do you adjust the page table (and any other data
>> structures) to reflect the frame Q no longer has?


>> B4: Explain your heuristic for deciding whether a page fault for an
>> invalid virtual address should cause the stack to be extended into
>> the page that faulted.

---- SYNCHRONIZATION ----

>> B5: Explain the basics of your VM synchronization design.  In
>> particular, explain how it prevents deadlock.  (Refer to the
>> textbook for an explanation of the necessary conditions for
>> deadlock.)

We know from lecture that for deadlock to be possible you must have: limited 
access, no preemption, multiple independent requests, and circularity in 
graph of requests. 

Our synchronization design removes circularity in the graph of requests.
We have two primary locking methods when it comes to the frames. We have
fine grained locks for each frame so that no one frame can be accessed
or editted at the same time. We also have a bitmap lock which ensures that
no two processes can evict at the same time and that parallel get_frame
or remove_frame calls can not happen. 

For swap we utilize a swap lock for two purposes. One is to ensure that
swap_add and swap_remove calls can not happen at the same time. And second
to ensure that simultaneous swap_add or simultaneous swap_remove calls
are not possible. 

For both swap and frame we keep the ordering consistent
to ensure that out of order locking issues do not occur. 

>> B6: A page fault in process P can cause another process Q's frame
>> to be evicted.  How do you ensure that Q cannot access or modify
>> the page during the eviction process?  How do you avoid a race
>> between P evicting Q's frame and Q faulting the page back in?

In the event that P is evicting and Q page faults on the page being evicted,
Q will call our load_page function which calls get_frame() to get the page
from the supplemental page table at the address which we faulted at. 
Our get_frame() call is locked using our bitmap_lock and will not fetch 
any frame until the bitmap_lock is released. Whenever we call evict_algo 
it is protected using the bitmap_lock as well. This ensures that process 
Q will not be able to access or modify the frame until after the eviction 
algorithm completes. 

>> B7: Suppose a page fault in process P causes a page to be read from
>> the file system or swap.  How do you ensure that a second process Q
>> cannot interfere by e.g. attempting to evict the frame while it is
>> still being read in?

pin every frame when created and unpin when finished creating so can not be
evicted. 

>> B8: Explain how you handle access to paged-out pages that occur
>> during system calls.  Do you use page faults to bring in pages (as
>> in user programs), or do you have a mechanism for "locking" frames
>> into physical memory, or do you use some other design?  How do you
>> gracefully handle attempted accesses to invalid virtual addresses?

In this situation we do not utilize page faulting. Our verify pointer call
pins all the pages being accessed by that pointer. This in essence sets the
frame pinned boolean to true for these frames. This ensures that any eviction
will skip over any pinned pages so that we do not page fault in the kernel.

This ensures that if in this situation if we are working with an invalid
virtual address we first must check if it is in the suppl
We gracefully handle attempted accesses to invalid virtual addresses by
calling our exit_handler(-1). We do this by checking the pagedirectory
and the supplemental page table to ensure that every page is a valid
address in either one otherwise we call exit_handler(-1)


---- RATIONALE ----

>> B9: A single lock for the whole VM system would make
>> synchronization easy, but limit parallelism.  On the other hand,
>> using many locks complicates synchronization and raises the
>> possibility for deadlock but allows for high parallelism.  Explain
>> where your design falls along this continuum and why you chose to
>> design it this way.

We utilize a combination of larger locks such as our bitmap_lock and
fine grained locks such as our frame_entry locks to lock in differing
situations and to lock large chunks of memory or high traffic areas 
for the minimum time possible. 

We felt that solely having large locks would limit parallelism in many ways, 
but that having solely course grained locks would make actions such as multiple
processess calling get_frame, evict_algo, swap_remove, or swap_add. In other
situations when we are working only with specific frames we allow for a finer
grained lock so that as much parallelism as possible can occur in those cases.

             MEMORY MAPPED FILES
             ===================

---- DATA STRUCTURES ----

>> C1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

---- ALGORITHMS ----

>> C2: Describe how memory mapped files integrate into your virtual
>> memory subsystem.  Explain how the page fault and eviction
>> processes differ between swap pages and other pages.

>> C3: Explain how you determine whether a new file mapping overlaps
>> any existing segment.

---- RATIONALE ----

>> C4: Mappings created with "mmap" have similar semantics to those of
>> data demand-paged from executables, except that "mmap" mappings are
>> written back to their original files, not to swap.  This implies
>> that much of their implementation can be shared.  Explain why your
>> implementation either does or does not share much of the code for
>> the two situations.

               SURVEY QUESTIONS
               ================

Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the course evaluations at the end of
the quarter.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

>> Do you have any suggestions for the TAs to more effectively assist
>> students, either for future quarters or the remaining projects?

>> Any other comments?

            +---------------------------+
            |          CS 212           |
            | PROJECT 3: VIRTUAL MEMORY |
            |      DESIGN DOCUMENT      |
            +---------------------------+

---- GROUP ----

>> Fill in the names and email addresses of your group members.
Angel Ruiz <ar7@stanford.edu>
Pilli Cruz-De Jesus <pilli@stanford.edu>
Fabian Luna <luna1206@stanford.edu>

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.

            PAGE TABLE MANAGEMENT
            =====================

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

/* This is our supplemental page struct, it keeps
track of all information needed to retrieve a page
of information in swap or file and write it to memory. */
struct page {
    /* In Memory */
    struct frame_entry *frame;
    void *physical_addr;

    /* In Disk */
    struct file *file;
    off_t file_ofs;
    size_t page_read_bytes;
    size_t page_zero_bytes;
    mapid_t mapid;

    /* In Swap*/
    int swap_slot;

    /* Everything */
    void *virtual_addr;
    struct hash_elem hash_elem;
    struct thread *process_reference;
    short memory_flag;    
    bool writable;
};

/* This member was added into the thread struct so that each process can manage its own SPT. */
struct hash spt;

---- ALGORITHMS ----

>> A2: In a few paragraphs, describe your code for accessing the data
>> stored in the SPT about a given page.
Our SPT is in the form of a hash table, and each one of its items is represented by our 
page struct. For this reason, all of our page logic with the SPT uses functions like 
hash_insert and hash_find to access and interact with the stored page data. In our 
implementation, we only use two functions to access the data stored about a given page: 
page_fetch and load_page. These functions fetch the page data from the SPT and load the page
into the memory, respectively.

page_fetch is a rather simple function, and simply grabs the page reference from a given 
thread's SPT. We first begin by rounding down a user address to find the page entry that
corresponds to that address. We then declare a struct page variable, but only fill in the
virtual address for that page, so that we can pass it into the hash_find function. This 
function finds the hash_elem with the corresponding user address if it exists, and returns 
NULL if it doesn't. We then use the hash_entry call in order to convert the hash_elem that 
into a struct page and return it.

load_page first tries to find a page entry in the SPT for a given fault_addr. If the 
fault_addr returns NULL, we check to see if our stack is trying to grow itself; if not,
we return false, because there's no page to load from the SPT. If we do have an address,
however, we fetch the frame for that given user page; if the page has not yet had a 
physical_address assigned to it, we return false. In the event that there is a frame 
for that address, we then fetch that data, whether it is zeroed, on swap, etc, and set
that information in the page, along with its memory flag to indicate it's in memory. If 
there is any errors that we encounter after we've fetched the frame, we make sure to free
the frame before returning false.

>> A3: How does your code coordinate accessed and dirty bits between
>> kernel and user virtual addresses that alias a single frame, or
>> alternatively how do you avoid the issue?
To avoid any extra configuration with our codebase, we chose to exclusively access data 
through user virtual addresses. By avoiding any use of the actual physical address that
a given virtual page is mapped to, we completely avoid dealing with data inconsistencies
that may arise from holding that underlying kernel page. We have also not implemented
file sharing at any point in time, so there are no other aliasing situations that can
arise in our ecosystem.

Only access through user ?

---- SYNCHRONIZATION ----

>> A4: When two user processes both need a new frame at the same time,
>> how are races avoided?
When we call get_frame, we get the new frame by accessing and modifying a bitmap with the
bitmap_scan_and_flip call. In order to avoid races in this scenario, we have a bitmap_lock 
that is a static global that we define in page.c. This lock is initialized in the 
frame_table_init call, so we know that all threads will be able to access and use this lock
as required. We use this lock when modifying the bitmap during a get_frame or free_frame
call so that there are no read/write inconsistencies that may arise from races when 
freeing/getting frames.

---- RATIONALE ----

>> A5: Why did you choose the data structure(s) that you did for
>> representing virtual-to-physical mappings?
We used our page struct to represent our virtual-to-physical mappings. In this struct, the 
virtual_addr, hash_elem, process_reference, memory_flag, and writeable boolean are always 
used. This allows us to manage the page and retrive information about it no matter where
the kernel page for that user address is. In the event that the kernel page is in memory, 
swap, or on disk, we can simply check our memory_flag and do certain actions with or on that
page. Once checking this flag, we can then go on to use certain member variables that apply
and can be used in each corresponding situation.

               PAGING TO AND FROM DISK
               =======================

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

---- ALGORITHMS ----

>> B2: When a frame is required but none is free, some frame must be
>> evicted.  Describe your code for choosing a frame to evict.

>> B3: When a process P obtains a frame that was previously used by a
>> process Q, how do you adjust the page table (and any other data
>> structures) to reflect the frame Q no longer has?

>> B4: Explain your heuristic for deciding whether a page fault for an
>> invalid virtual address should cause the stack to be extended into
>> the page that faulted.

---- SYNCHRONIZATION ----

>> B5: Explain the basics of your VM synchronization design.  In
>> particular, explain how it prevents deadlock.  (Refer to the
>> textbook for an explanation of the necessary conditions for
>> deadlock.)

>> B6: A page fault in process P can cause another process Q's frame
>> to be evicted.  How do you ensure that Q cannot access or modify
>> the page during the eviction process?  How do you avoid a race
>> between P evicting Q's frame and Q faulting the page back in?

>> B7: Suppose a page fault in process P causes a page to be read from
>> the file system or swap.  How do you ensure that a second process Q
>> cannot interfere by e.g. attempting to evict the frame while it is
>> still being read in?

>> B8: Explain how you handle access to paged-out pages that occur
>> during system calls.  Do you use page faults to bring in pages (as
>> in user programs), or do you have a mechanism for "locking" frames
>> into physical memory, or do you use some other design?  How do you
>> gracefully handle attempted accesses to invalid virtual addresses?

---- RATIONALE ----

>> B9: A single lock for the whole VM system would make
>> synchronization easy, but limit parallelism.  On the other hand,
>> using many locks complicates synchronization and raises the
>> possibility for deadlock but allows for high parallelism.  Explain
>> where your design falls along this continuum and why you chose to
>> design it this way.

             MEMORY MAPPED FILES
             ===================

---- DATA STRUCTURES ----

>> C1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

---- ALGORITHMS ----

>> C2: Describe how memory mapped files integrate into your virtual
>> memory subsystem.  Explain how the page fault and eviction
>> processes differ between swap pages and other pages.

>> C3: Explain how you determine whether a new file mapping overlaps
>> any existing segment.

---- RATIONALE ----

>> C4: Mappings created with "mmap" have similar semantics to those of
>> data demand-paged from executables, except that "mmap" mappings are
>> written back to their original files, not to swap.  This implies
>> that much of their implementation can be shared.  Explain why your
>> implementation either does or does not share much of the code for
>> the two situations.

               SURVEY QUESTIONS
               ================

Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the course evaluations at the end of
the quarter.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

>> Do you have any suggestions for the TAs to more effectively assist
>> students, either for future quarters or the remaining projects?

>> Any other comments?

             +--------------------------+
             |          CS 212          |
             | PROJECT 2: USER PROGRAMS |
             |     DESIGN DOCUMENT      |
             +--------------------------+

---- GROUP ----

>> Fill in the names and email addresses of your group members.

Angel Ruiz <ar7@stanford.edu>
Pilli Cruz-De Jesus <pilli@stanford.edu>
Fabian Luna <luna1206@stanford.edu>

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.

               ARGUMENT PASSING
               ================

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

/* Limit for how many characters the user can type in the command line */
#define CMDLINE_CHAR_LIMIT 128

---- ALGORITHMS ----

>> A2: Briefly describe how you implemented argument parsing.  How do
>> you arrange for the elements of argv[] to be in the right order?
>> How do you avoid overflowing the stack page?

    We handle argument passing in the call to setup_stack in the load function. 
    When we create a new process, we create a new thread that runs the 
    start_process function. When this function runs, it calls the load function
    which then calls setup_stack. In the load function, if we find that the 
    length of the command line input is greater than CMDLINE_CHAR_LIMIT, load
    will fail and we will not setup the stack. We pass in the entire filename 
    string, including arguments into setup_stack, so we can parse the necessary
    values and place them in the stack using the esp pointer.

    In setup_stack, we make sure to only begin stack initialization if the page
    is installed successfully. If this is the case, we initialize an argc 
    variable. We then count the total number of characters we will need to push
    onto the stack (sum of the sizes of each arg string and their null
    characters) by looping through the command line input characters. We ignore
    whitespace in the total count and make sure to add to the count for every
    null terminators we will need. We also caculate the argc value within this
    loop by incrementing it whenever we find that we need to account for a
    null terminator.

    We set the esp pointer to point to PHYS_BASE. We then subtract the amount
    of characters we are going to push onto the stack from the esp pointer to
    know where start if the arguments on the stack will begin. We also
    initialize an array of char * pointers of size argc to save the location
    in memory of each arg string pushed on the stack.
    After this, we copy our cmdline string, and place it into a loop with 
    strtok_r, so that we pull all of the words out of our string. For
    every word we pull with strtok_r, we make sure to copy that string into 
    the current location of esp, and save the esp pointer into the argv array.
    Then we offset esp upwards to account for the size of that string. 
    After this is done, our esp pointer should be as location PHYS_BASE. We
    set esp pointer back to the start of the arguments in the stack, below 
    the first argument from the command line. We make sure that our esp pointer
    is four-byte aligned and decrement esp as necessary.

    With this managed, we determine where our esp pointer will be pointing to
    after everything has been pushed onto the stack by subtracting the number
    of bytes that will needed to push the return address, argc, the base argv
    pointer, and all of the individual argv pointers that follow. We begin at
    esp's final location set a "return adress" of 0 and push it onto the stack,
    incrementing the esp pointer by sizeof(int) afterwords. Finally, we push
    the values of argc, the address of argv, and the address of all the
    arguments of argv using this same logic. At this point, our esp pointer
    should be back where we were after aligning the pointer for 4 bytes
    alignment. We set esp back to point right below the return address.

    This algorithm works by calculating how much space will be needed for what
    we want to push onto the stack, moving the esp to point to the base of
    where those pushed arguments will begin, and push them onto the stack in
    order. We always have to reset back to the intial point we calculated
    because we push from the stack bottom to up and need to return the stack
    pointer back to the bottom of where we inserted.


---- RATIONALE ----
>> A3: Why does Pintos implement strtok_r() but not strtok()?

    According to the Linux Programmer's Manual (found by running "man strtok_r"), 
    strtok_r is a reentrant version of strtok. strtok_r maintains its context
    amongst different calls by using the saveptr variable. By doing this, we allow
    multiple strings to be parsed concurrently using strtok_r. Since strtok doesn't 
    have a saveptr variable, we wouldn't be able to parse multiple strings 
    concurrently or parse strings in nested loops with it. 

>> A4: In Pintos, the kernel separates commands into a executable name
>> and arguments.  In Unix-like systems, the shell does this
>> separation.  Identify at least two advantages of the Unix approach.

    One advantage of this approach would be that all of our error-handling logic
    can be condensed into the shell, rather than placing this load on the kernel.
    This brings more security into our processing system, because all validation
    is done on the user-side, and not on the kernel side where things are much
    more volatile. There is also one less layer of indirection when the shell 
    has the sole responsibility of parsing commands and subprocessing.

    In general, this brings another advantage as well. By removing the need to
    parse and validate these commands in the kernel, the UNIX approach is much 
    more efficent and uses less memory for the kernel. Alongside this the 
    complexity of doing this kernel side and having to pass
    alongside arguements is more difficult than if it were all taken care of
    before being switched to the kernel.


                 SYSTEM CALLS
                 ============

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

/*Global lock used in process and syscall files
which secures that the child_process struct is not being
exposed to race conditions */
struct lock process_lock;

/*This struct is in charge of all commmunication
between parent and a particular child. Makes it 
possible to wait, free correctly, pass error, etc*/
struct child_process
{
   tid_t tid;                    /*Threads tid*/
   int status;                   /*Threads status*/
   bool wait_called;             /*Has parent already called process_wait on child*/
   bool child_error;             /*Did the child encounter an error*/
   bool tried_to_free;           /*Did the parent try to free this child*/
   char *file_name;              /*Child thread file name*/
   struct semaphore wait_child;  /*Semaphore to make parent wait for start process to finish before finishing exec_proces*/
   struct list_elem wait_elem;   /*Elem for child to be put in parents list*/
   struct condition wait_cond;   /*Cond variable to wake up parent in process_wait when child exits*/
   struct lock wait_lock;        /*Lock to wake up parent in process_wait when child exits*/

};

/* The added members allows each thread to keep track
of the name of its executable file and pointer to its opened
executable file for the purpose of printing the name and closing
the executable when the process exits. The cur_fd and fd_list members
allow us to keep track of fd assignment and the process's current open
files.  We use the children to free at the end and communicate with the
child. We use *process to be able to free the child_process if needed
when exiting */
struct thread
{
   char exec_name[128];        /* Name used to print */
   struct file *exec_file;    /* File being executed*/
   int cur_fd;               /* Thread current fd number to assign */
   struct list fd_list;      /* Thread open file descriptors list */
   struct list children; /*List of this threads chilldren*/
   struct child_process *process; /*Pointer to the child_process of this thread*/
};

/* A global lock that allows us to synchronize all file system calls
across processes. Initialized once for all processes in thread_init. */
struct lock filesys_lock;

/* A struct to add files to threads' open file descriptors list */
struct fd_elem
{
  int fd;
  struct file *file;
  struct list_elem elem;
};

>> B2: Describe how file descriptors are associated with open files.
>> Are file descriptors unique within the entire OS or just within a
>> single process?

    File descriptors are only unique within a single process. Each 
    process's thread is initialized with its cur_fd member variable
    at 2. We do not want to assign any files we open an fd of 0 or 1
    because those are reserved for standard input and output. Whenever
    we open a file in a system call, we assign it an fd of cur_fd's
    value and create an fd_elem holding that fd and file pointer and
    add it to the process's thread's fd_list to keep track of all of the
    process's open files and their file descriptors. We then increment 
    the thread's cur_fd value by one so that the next call to open 
    assigns the newly opened file the next unassigned fd. The cur_fd 
    value will continue to be incremented with all calls to open and 
    will never decrement, even when closing files. Each process uses
    this system, so across processes there can be different files assigned
    the same fd, but processes never have to access the open files of
    another process so this is safe.


---- ALGORITHMS ----

>> B3: Describe your code for reading and writing user data from the
>> kernel.

    We implemented the verify_pointer and verify_string functions to
    ensure that all reading and writing user data from the kernel would
    be safe. The verify_pointer function takes in a pointer and the size
    of the data that it is verifying in bytes. If that pointer is null,
    or if the first or last byte of memory is a kernel address, then we
    exit with status -1 to avoid dereferencing invalid memory. We then
    check to ensure that the pointer is a user address and if not we
    exit with status -1. If it is a user address, we call pagedir_get_page()
    on both the first byte of data and the last byte of data to make sure
    that all bytes are mapped to a physical address. If any of those calls
    return NULL (memory is not mapped), then we exit with status -1.

    The verify_string function utilizes this verify_pointer function to
    verify that every char (byte) in a string is in valid memory. Because we do
    not know the length of the string before hand, we call call verify_pointer
    in a while loop that loops through every char in the string and either
    ends once a NULL character is found or exits with status -1 within a call
    to verify pointer.

    When a syscall is called, our handler verifies that every argument that we
    pop off the stack is in valid memory using verify pointer, including the
    syscall number. If all arguments are valid, we pass them into our syscall
    handler functions. For any of these functions that have char * as
    arguments passed in, such as open(), we verify that every byte of that 
    string is in valid memory using our verify string function. For functions
    that pass in buffers that will be written to, we verify that every byte
    of that buffer that we could potentially write to is valid by calling
    verify_pointer and passing in the length of the buffer that the user
    provided as an argument. This ensure that all user data that is read from
    and written to from the kernel is in valid memory.

    Lastly, we also updated the pagefault_handler so that is a user tries to
    derefence a NULL pointer or a kernel address within their process, we 
    exit with status -1 instead of page faulting.

>> B4: Suppose a system call causes a full page (4,096 bytes) of data
>> to be copied from user space into the kernel.  What is the least
>> and the greatest possible number of inspections of the page table
>> (e.g. calls to pagedir_get_page()) that might result?  What about
>> for a system call that only copies 2 bytes of data?  Is there room
>> for improvement in these numbers, and how much?

    In the worst case scenario, we will have to verify that every byte
    of the data is in valid memory using verify_pointer. This could be the
    case if the data being copied is a string. Every call to verify pointer
    makes 2 calls to pagedir_get_page(), so verifying each byte would cost
    2 * 4096 calls to pagedir_get_page. There are also the calls that come
    from the syscall_handler verifying the syscall number and arguments being
    popped off the stack, so with three arguments this would cost an extra
    8 calls. In total the maximum number of inspections for 4096 bytes of data
    could be 2 * 4096 + 8 = 8200. In the case that we know the size of data in
    bytes, such as the user passing in a buffer with length 4096, we would be
    able to verify the data with a single call to verify_pointer. If there are
    a minimum of two arguments with the pointer and the length and the syscall
    number, we could hypothetically have a syscall that handle 4096 bytes of 
    data with only 4 total calls to verify pointer which would mean that there
    could be a minimum of 2 * 4 = 8 inspections.
    
    If our system call is only hanlding 2 bytes of data, the maximum number
    of inspections would call for every byte to be verified. This means we
    could have up to 2 calls to verify_pointer and an additional 4 calls if
    3 arguments are passed in with the syscall number. This means that there
    could be a maximum of (2 + 4) * 2 = 12 calls to pagedir_get_page(). If
    our system call knows how big the data is in bytes, we could have a minimum
    of 1 call to verify pointer to verify the data and the additional
    verification from a minimum of 2 arguments and a system call. This could
    be a minumum of (1 + 2) * 2 = 6 inspections.

    There is a lot of potential room for improvement in these numbers if we
    were to force users to provide the size of all arguments they were passing
    in to syscall functions for parameters that may have unspecified lengths
    like strings. If this were the case, we could greatly decrease the amount
    of inspections needed when verifying the pointers to data for very big
    objects down to a single call to verify_pointer needed to verify the data
    of the parameter.

>> B5: Briefly describe your implementation of the "wait" system call
>> and how it interacts with process termination.

    Our wait implemententation checks to see if it has children if not 
    it will return -1. Then it will loop through children, which is
    a list of struct child_process which the current thread created,
    looking for the child_process with the requested tid. If not found 
    return -1. If found check if wait has been called, if so return -1.
    Otherwise check if the child->status != INITIAL_STATUS if so return
    status. Otherwise we fall into the most interesting case.

    When wait has not been called previously on the child, and 
    status = INITIAL_STATUS, then we must wait for child to exit. 
    This is done using a condition variable wait_cond and lock wait_lock
    which are shared between the child and parent through child_process.
    We put the parent to sleep with wait_cond in a while loop ensuring 
    that only if the child status which we are waiting on is no longer 
    INITIAL_STATUS will we stop sleeping. 

    We wake up the parent thread in the bottom of exit_handler. When
    we are in the situation where the parent has not yet exited, we
    know it must be waiting on the child to exit. In this case we 
    cond_signal the parent by using the shared wait_cond and protect
    the signal using the shared wait_lock to wake up the parent. 

    We also implemented freeing so that the last process to exit is the
    one which frees. This is handled through a boolean in the child_process 
    struct. 

>> B6: Any access to user program memory at a user-specified address
>> can fail due to a bad pointer value.  Such accesses must cause the
>> process to be terminated.  System calls are fraught with such
>> accesses, e.g. a "write" system call requires reading the system
>> call number from the user stack, then each of the call's three
>> arguments, then an arbitrary amount of user memory, and any of
>> these can fail at any point.  This poses a design and
>> error-handling problem: how do you best avoid obscuring the primary
>> function of code in a morass of error-handling?  Furthermore, when
>> an error is detected, how do you ensure that all temporarily
>> allocated resources (locks, buffers, etc.) are freed?  In a few
>> paragraphs, describe the strategy or strategies you adopted for
>> managing these issues.  Give an example.

    By creating the verify_pointer and verify_strings functions, we created
    a non-obscure way to allow each syscall function to focus on the
    primary focus of the syscall functions code. We make sure to always verify
    pointers and strings before ever accessing the data using these helper
    functions, which abstracts that logic out of all the spots where we need
    to verify pointers.

    Furthermore, all the logic that detects invalid memory in our functions
    lead to one logical path, calling the exit handler. Because of this, we are
    able to place all of our code that frees any resources that we may have
    temporarily allocated in that function. We allocate memory for things such
    as child_process structs and fd_elems that threads keep track of for their
    purposes. We are able to free these structs as necessary within this
    exit_handler function and make sure we do not leak any memory. It is
    helpful to have the processes threads keep track of their own allocated
    memory because it makes it easier to access and free their memory in the
    exit_handler function, where all processes go to die in the case of any
    errors.

    For example, each thread has a fd_list of fd_elems that correspond to their
    open file descriptors. These fd_elems are malloced to ensure that they are
    available past the completion of the open system call. If we try to
    derefence and invalid pointer and catch that in verify_pointer, our system
    will exit with status -1, and in this exit handler we are able to loop
    through the process thread's fd list and both close and free all files
    in the open file descriptor list.

---- SYNCHRONIZATION ----

>> B7: The "exec" system call returns -1 if loading the new executable
>> fails, so it cannot return before the new executable has completed
>> loading.  How does your code ensure this?  How is the load
>> success/failure status passed back to the thread that calls "exec"?

    In the child_process struct we have a semaphore called wait_child. 
    In process_execute we first initialize the child process' 
    child_process. We then create the new thread and pass the new 
    child_process through the thread_create() call. We add this child to
    the parents list of children. We then make the parent wait until the
    child has finished start_process using sema_down(&wait_child).
    
    Passing the child_process through thread_create() gives us access to
    child_process in the childs call to start_process. At the end of 
    start_process, after the load has been completed we can see if the 
    load was done successfully through the success boolean. If sucess 
    is true we will wake up the parent using sema_up(&wait_child). If 
    unsuccessful we set the child_process' child_error boolean to true,
    wake up the parent using sema_up(&wait_child), and thread_exit().

    The sema_up wakes up the parent and we are back in process_execute. 
    At this point we check the child_process' child_error, If it is
    true return -1, otherwise finish as usual. This wait_child semaphore 
    ensures that the parent must wait until after the child thread has 
    loaded to finish process_execute(). The shared child_process struct 
    allows for information to easily be passed between parent and child.

>> B8: Consider parent process P with child process C.  How do you
>> ensure proper synchronization and avoid race conditions when P
>> calls wait(C) before C exits?  After C exits?  How do you ensure
>> that all resources are freed in each case?  How about when P
>> terminates without waiting, before C exits?  After C exits?  Are
>> there any special cases?

Freeing:
    In our program freeing is handled by whoever uses the struct last. 
    This implementation is done using using a boolean in the shared
    child_process called tried_to_free. This will works regardless of
    if the parent waits for the child.

    If your are process C and are exiting you will check tried_to_free.
    If true, it means that your parent P has exited and you must free the 
    shared child_process. If tried_to_free is false it means that P 
    is alive and you will NOT free the child_process because P will 
    do it later.

    Similarly, if your are P and are exiting you will check tried_to_free.
    If true, it means that C has exited and you must free the 
    shared child_process. If tried_to_free is false it means that C 
    is alive and you will NOT free the child_process because C will 
    do it later.

    Lastly, all processes close their open files in our exit handler. After 
    freeing all necessary children, each process loops through its list of 
    open files, and closes each file. In this loop, we also make sure to 
    free the corresponding fd_elem struct associated with it, since we 
    initialized it using malloc. Although we free the fd_elem every time, 
    we use file_close to close our file descriptors. This ensures that we 
    do not fully close a file until all processes who are accessing it have
    terminated.

Case 1: P alive, waiting on C to exit:
    In the case where P is waiting for C and C has not exited
    our program waits for C to exit. 

    This is done using a condition variable wait_cond and lock wait_lock
    which are shared only between C and P through child_process.
    We put the parent to sleep with wait_cond in a while loop ensuring 
    that only if the child status which we are waiting on is no longer 
    INITIAL_STATUS will we stop sleeping. Here the wait_lock protects
    wait_cond from any race conditions. 

Case 2: P alive, waiting on C, C already exitted:

    In the case where P is waiting for C and C has exited our program
    will return the childs exit status, which is kept updated through
    the shared child_process. Any changes to child_process are protected
    by process_lock and can not have race conditions.  

In both cases 1 and 2 P will be the last process to use child_process.
Therefore as described above in our Freeing section the shared 
child_process struct will not be freed until P exits. 
This makes it so that we have no race conditions for this struct 
because only the parent will have access to the child_process since
the child will have exited when we eventually free. 

Case 3: P Exit, no waiting, C alive:
    In the case where P has exited and C is running. C will not need any
    information inside of P since all shared information will be kept
    alive through the shared child_process. When C is exiting we will
    see that since the parent has exited tried_to_free = true. Therefore
    C will free the shared child_process and will not signal the parent 
    since the parent has already exited.  

Case 4: P Exits after C exits, no waiting:
    C exits, but parent exits, parent will not need any information from 
    inside of the child thread and will also not wait for it. There will
    be no race conditions because since P is the last process to exit
    it will close child_process. As described in the Freeing section. 

Case 5: Special case, Both exit simultaneously:
    The special case where both a child and parent exit simultaneously is
    not possible. We do not need to worry about this case because it is not 
    possible. Because of our use of locking through process lock one will 
    always finish first and we will arrive in one of the 4 cases above. 

Case 6: Special Case Parent or child or both running infinitely:
    Depending on what the program is doing we will either run out of memory
    and catch the error exiting with -1. Or in the case that the process 
    running infinitely does not reallocate or use more memory we will hang. 
    This will allow the user to send a halt or interrupt for their program 
    to stop the hang. This s a valid output because most terminals, shells, 
    etc force the user to end infinite programs themselves. 

---- RATIONALE ----

>> B9: Why did you choose to implement access to user memory from the
>> kernel in the way that you did?

    We believed that having these verify_pointer and verify_string
    pointer functions that catch invalid access to memory before dereferencing
    were a better design decision as opposed to modifying the page fault
    handler and adding all of our logic in that function because it makes
    the logic of our handling user memory access less obscure. Rather than
    allowing the page fault to always happen, we were able to ensure that we
    never allowed an invalid access to occur exited with status -1 straight
    away. We think this is a cleaner approach and benefits anyone who reads
    our source code as they will be able to understand our logic much easier.

>> B10: What advantages or disadvantages can you see to your design
>> for file descriptors?

    By having each thread have a local copy of its open file descriptors
    list, there is no need to ensure synchronization between processes and
    their fd_list when opening and closing files. Although there can be
    duplicate file descriptors across processes that point to different files,
    their functionality makes it so that this is not a problem. Also, because
    we store fd_elems in a list, adding new open files to the list can be done
    in constant time. Our because we neglect closing files in our fd assignment
    process, we also have an efficient way to assign file descriptors to files.
    The next opened file is always assigned the incremented cur_fd value.

    Some disadvantages of this are that if we were to need to extend the 
    functionality of this fd system if processes needed to know the number
    of other processes who have the same file open, our current system would
    require a very inefficient solution that looks through all lists. In that
    case, it could be more efficient to have a single global fd list. Also,
    because our fd_elems are stored in a list, lookup time is linear in the
    case that we need to find a certain fd. A hashmap could potentially
    provide a faster lookup time in these scenarios.

>> B11: The default tid_t to pid_t mapping is the identity mapping.
>> If you changed it, what advantages are there to your approach?
    We did not use an alternate mapping system in our implementation.

               SURVEY QUESTIONS
               ================

Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the course evaluations at the end of
the quarter.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

>> Do you have any suggestions for the TAs to more effectively assist
>> students, either for future quarters or the remaining projects?

>> Any other comments?
